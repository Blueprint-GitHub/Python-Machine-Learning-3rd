{"cells":[{"cell_type":"markdown","metadata":{"id":"xmbVJ9vurVP7"},"source":["# **이진 분류**"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":8090,"status":"ok","timestamp":1699259648204,"user":{"displayName":"김태식","userId":"11264777984025639378"},"user_tz":-540},"id":"f8zxl-tCrbSU","outputId":"a5ca57e0-bde1-4e2c-9e57-f7bb8059d265"},"outputs":[{"name":"stdout","output_type":"stream","text":["Selecting previously unselected package fonts-nanum.\n","(Reading database ... 120874 files and directories currently installed.)\n","Preparing to unpack .../fonts-nanum_20200506-1_all.deb ...\n","Unpacking fonts-nanum (20200506-1) ...\n","Setting up fonts-nanum (20200506-1) ...\n","Processing triggers for fontconfig (2.13.1-4.2ubuntu5) ...\n"]}],"source":["import sys\n","\n"," # 노트북이 코랩에서 실행 중인지 체크합니다.\n","if 'google.colab' in sys.modules:\n","    !echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections\n","    # 나눔 폰트를 설치합니다.\n","    !sudo apt-get -qq -y install fonts-nanum\n","    import matplotlib.font_manager as fm\n","    font_files = fm.findSystemFonts(fontpaths=['/usr/share/fonts/truetype/nanum'])\n","    for fpath in font_files:\n","        fm.fontManager.addfont(fpath)\n","    # 나눔바른고딕 폰트로 설정합니다.\n","    import matplotlib.pyplot as plt\n","    plt.rc('font', family='NanumBarunGothic')\n","   # 마이너스 기호 표시 오류 수정\n","    import matplotlib\n","    matplotlib.rcParams['axes.unicode_minus'] = False"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JhjbCadbrbjW"},"outputs":[],"source":["# 기본 그래프 폰트 설정\n","import matplotlib.pyplot as plt\n","\n","plt.rc('font', size=14)\n","plt.rc('axes', labelsize=14, titlesize=14)\n","plt.rc('legend', fontsize=14)\n","plt.rc('xtick', labelsize=10)\n","plt.rc('ytick', labelsize=10)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":34067,"status":"ok","timestamp":1699259682270,"user":{"displayName":"김태식","userId":"11264777984025639378"},"user_tz":-540},"id":"adO8jmDxDtCH","outputId":"6fdda9c9-e7b7-4375-a6ef-1d4fbabe6e3a"},"outputs":[{"name":"stderr","output_type":"stream","text":["/usr/local/lib/python3.10/dist-packages/sklearn/datasets/_openml.py:968: FutureWarning: The default value of `parser` will change from `'liac-arff'` to `'auto'` in 1.4. You can set `parser='auto'` to silence this warning. Therefore, an `ImportError` will be raised from 1.4 if the dataset is dense and pandas is not installed. Note that the pandas parser may return different data types. See the Notes Section in fetch_openml's API doc for details.\n","  warn(\n"]}],"source":["# 파일 다운로드\n","from sklearn.datasets import fetch_openml\n","\n","mnist = fetch_openml('mnist_784', as_frame = False) # True시 pandas로 반환"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Iwc-CeW7MWn9"},"outputs":[],"source":["X, y = mnist.data, mnist.target\n","\n","#train_input, test_input, train_target, test_target\n","X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YAGrs9zlNjLT"},"outputs":[],"source":["# 간단한 이진 분류 테스트\n","y_train_5 = (y_train == '5') # 불리언 인덱싱\n","y_test_5 = (y_test == '5')"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"NsCwz2AENsJm"},"outputs":[],"source":["from sklearn.linear_model import SGDClassifier\n","from sklearn.model_selection import cross_val_score\n","\n","sgd_clf = SGDClassifier(random_state = 42)\n","sgd_clf.fit(X_train, y_train_5)\n","\n","cross_val_score(sgd_clf, X_train, y_train_5, cv = 3, scoring = 'accuracy')\n","# 아무렇게나 예측해도 90% 가 나오므로, 정확도는 좋은 측정 지표가 아님."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bZcsYD83QBzP"},"outputs":[],"source":["# 이때는 오차 행렬을 사용하는게 좋음(잘못 분류된 클래스 비율)\n","from sklearn.model_selection import cross_val_predict\n","from sklearn.metrics import confusion_matrix\n","\n","\"\"\"오차 행렬을 만드는 방법은 순수한 예측을 반환한 다음,\n","   타깃 클래스와 예측 클래스로 행렬을 만들면 됨.\n","\"\"\"\n","y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3)\n","cm = confusion_matrix(y_train_5, y_train_pred)\n","print(cm)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zidkF41oS9vl"},"outputs":[],"source":["\"\"\"\n","오차 행렬외에 클래스 분류 점수를 보여주는 정밀도와 재현율 점수도 구현 가능\n","정밀도 : 양성으로 분류한 것 중에 진짜 양성 개수 (5,5,5,6) -> 75%\n","재현율 : 양성 샘플인데 음성으로 분류한 개수 (숫자가 5인데 5가 아니라고 분류한 것)\n","\n","정밀도와 재현율은 trade-off 관계에 있다.\n","\"\"\"\n","from sklearn.metrics import precision_score, recall_score\n","print(f\"정밀도 : {precision_score(y_train_5, y_train_pred)}\")\n","print(f\"재현율 : {recall_score(y_train_5, y_train_pred)}\")\n","\n","\"\"\"\n","그리고 이 두가지 점수를 하나로 합친(조화 평균) F1 점수\n","두 점수가 비슷할수록 f1 점수는 높은데, 이게 높다고 항상 바람직한건 아니다\n","상황에 따라 정밀도가 더 요구될 수도, 재현율이 더 요구될 수도 있기 때문이다.\n","\"\"\"\n","from sklearn.metrics import f1_score\n","print(f\"F1 Score : {f1_score(y_train_5, y_train_pred)}\")\n","\n","\"\"\"\n","SGDClassifier는 자신이 결정한 어떤 임곗값을 기준으로 음성,양성으로 나눈다.\n","이 임곗값을 지정할 순 없지만, 몇을 사용했는지는 알 수 있다.\n","\"\"\"\n","y_scores = sgd_clf.decision_function([X[0]])\n","print(f\"결정 점수 : {y_scores}\")"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Z-QMTw5rX0kb"},"outputs":[],"source":["\"\"\"\n","적절한 임곗값이 얼마쯤일지 확인해볼 수 있을까?\n","\"\"\"\n","from sklearn.metrics import precision_recall_curve\n","import matplotlib.pyplot as plt\n","\n","# 모든 샘플의 결정 점수 반환\n","y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3,\n","                             method = 'decision_function')\n","\n","# 모든 임곗값에 대한 정밀도, 재현율 반환\n","threshold = 3000 # 임곗값\n","precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)\n","# 기다란 넘파이 배열 반환"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"WC2jLobQa8Ia"},"outputs":[],"source":["#그래프로 그려보기\n","plt.figure(figsize=(8, 4))  # 추가 코드\n","plt.plot(thresholds, precisions[:-1], \"b--\", label=\"Precision\", linewidth=2)\n","plt.plot(thresholds, recalls[:-1], \"g-\", label=\"Recall\", linewidth=2)\n","plt.vlines(threshold, 0, 1.0, \"k\", \"dotted\", label=\"threshold\")\n","\n","# 추가 코드 –\n","idx = (thresholds >= threshold).argmax()  # 첫 번째 index ≥ threshold\n","plt.plot(thresholds[idx], precisions[idx], \"bo\")\n","plt.plot(thresholds[idx], recalls[idx], \"go\")\n","plt.axis([-50000, 50000, 0, 1])\n","plt.grid()\n","plt.xlabel(\"Threshold\")\n","plt.legend(loc=\"center right\")\n","\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cDkh9dvselHu"},"outputs":[],"source":["# 정밀도 / 재현율 곡선\n","# 재현율 80% 지점부터 급격하게 하락함, 따라서 정밀도 80~85% 재현율 60~70% 정도로 선택하는것이 합리적\n","# 아래 코드처럼 정밀도 90%으로 만들면 재현율이 약 48%라서 불량함.\n","import matplotlib.patches as patches  # 추가 코드 – 구부러진 화살표를 그리기 위해서\n","\n","plt.figure(figsize=(6, 5))  # 추가 코드\n","\n","plt.plot(recalls, precisions, linewidth=2, label=\"Precision/Recall curve\")\n","\n","# extra code – just beautifies and saves Figure 3–6\n","plt.plot([recalls[idx], recalls[idx]], [0., precisions[idx]], \"k:\")\n","plt.plot([0.0, recalls[idx]], [precisions[idx], precisions[idx]], \"k:\")\n","plt.plot([recalls[idx]], [precisions[idx]], \"ko\",\n","         label=\"Point at threshold 3,000\")\n","plt.gca().add_patch(patches.FancyArrowPatch(\n","    (0.79, 0.60), (0.61, 0.78),\n","    connectionstyle=\"arc3,rad=.2\",\n","    arrowstyle=\"Simple, tail_width=1.5, head_width=8, head_length=10\",\n","    color=\"#444444\"))\n","plt.text(0.56, 0.62, \"Higher\\nthreshold\", color=\"#333333\")\n","plt.xlabel(\"Recall\")\n","plt.ylabel(\"Precision\")\n","plt.axis([0, 1, 0, 1])\n","plt.grid()\n","plt.legend(loc=\"lower left\")\n","\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Ctp1FmTxg1ph"},"outputs":[],"source":["\"\"\"\n","정밀도/재현율 곡선 외에도 ROC(수신기 조작 특성)곡선을 활용할 수 있다\n","ROC곡선은 1 - 진짜 음성 비율TNR( = 거짓 양성 비율)의 곡선이다.\n","TNR을 특이도 라고도 하는데, 따라서 ROC곡선은 민감도(재현율)에 대한\n","1 - 특이도 곡선이라고 부를 수 있다.\n","\n","ROC곡선과 정밀도/재현율 곡선(PR)곡선 중 어느것을 사용해야 할까?\n","양성 클래스가 드물거나 거짓 음성보다 거짓 양성이 중요할때는 PR곡선\n","그 외에는 ROC 곡선을 사용한다.\n","\"\"\"\n","from sklearn.metrics import roc_curve\n","\n","# 모든 샘플의 결정 점수 반환\n","y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3,\n","                             method = 'decision_function')\n","\n","fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ZWQs08wUiIWv"},"outputs":[],"source":["idx_for_90_precision = (precisions >= 0.90).argmax()\n","threshold_for_90_precision = thresholds[idx_for_90_precision]\n","\n","idx_for_threshold_at_90 = (thresholds <= threshold_for_90_precision).argmax()\n","tpr_90, fpr_90 = tpr[idx_for_threshold_at_90], fpr[idx_for_threshold_at_90]\n","\n","plt.figure(figsize=(6, 5))  # 추가 코드\n","plt.plot(fpr, tpr, linewidth=2, label=\"ROC curve\")\n","plt.plot([0, 1], [0, 1], 'k:', label=\"Random classifier's ROC curve\")\n","plt.plot([fpr_90], [tpr_90], \"ko\", label=\"Threshold for 90% precision\")\n","\n","# 추가 코드\n","plt.gca().add_patch(patches.FancyArrowPatch(\n","    (0.20, 0.89), (0.07, 0.70),\n","    connectionstyle=\"arc3,rad=.4\",\n","    arrowstyle=\"Simple, tail_width=1.5, head_width=8, head_length=10\",\n","    color=\"#444444\"))\n","plt.text(0.12, 0.71, \"Higher\\nthreshold\", color=\"#333333\")\n","plt.xlabel('False Positive Rate (Fall-Out)')\n","plt.ylabel('True Positive Rate (Recall)')\n","plt.grid()\n","plt.axis([0, 1, 0, 1])\n","plt.legend(loc=\"lower right\", fontsize=13)\n","\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8w_r5oV2l6Nv"},"outputs":[],"source":["\"\"\"\n","SGDClassifier말고 RandomForestClassifier도 사용해보자.\n","\"\"\"\n","from sklearn.ensemble import RandomForestClassifier\n","\n","forest_clf = RandomForestClassifier(random_state = 42)\n","y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv = 3,\n","                                    method = \"predict_proba\")\n","\n","y_scores_forest = y_probas_forest[:, 1]\n","precisions_forest, recalls_forest, thresholds_forest = precision_recall_curve(\n","    y_train_5, y_scores_forest)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QEuqE3C1mobB"},"outputs":[],"source":["plt.figure(figsize=(6, 5))\n","\n","plt.plot(recalls_forest, precisions_forest, \"b-\", linewidth=2,\n","         label=\"Random Forest\")\n","plt.plot(recalls, precisions, \"--\", linewidth=2, label=\"SGD\")\n","plt.xlabel(\"Recall\")\n","plt.ylabel(\"Precision\")\n","plt.axis([0, 1, 0, 1])\n","plt.grid()\n","plt.legend(loc=\"lower left\")\n","\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OIvzkGM2mg0d"},"outputs":[],"source":["from sklearn.metrics import roc_auc_score\n","\n","y_train_pred_forest = y_probas_forest[:, 1] >= 0.5  # 양성 확률 ≥ 50%\n","print(f1_score(y_train_5, y_train_pred_forest))\n","print(roc_auc_score(y_train_5, y_scores_forest))\n","print(precision_score(y_train_5, y_train_pred_forest))\n","print(recall_score(y_train_5, y_train_pred_forest))"]},{"cell_type":"markdown","metadata":{"id":"sYBgxwpFrITN"},"source":["# **다중분류**"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bLHYzp8vx1mz"},"outputs":[],"source":["import sys\n","\n"," # 노트북이 코랩에서 실행 중인지 체크합니다.\n","if 'google.colab' in sys.modules:\n","    !echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections\n","    # 나눔 폰트를 설치합니다.\n","    !sudo apt-get -qq -y install fonts-nanum\n","    import matplotlib.font_manager as fm\n","    font_files = fm.findSystemFonts(fontpaths=['/usr/share/fonts/truetype/nanum'])\n","    for fpath in font_files:\n","        fm.fontManager.addfont(fpath)\n","    # 나눔바른고딕 폰트로 설정합니다.\n","    import matplotlib.pyplot as plt\n","    plt.rc('font', family='NanumBarunGothic')\n","   # 마이너스 기호 표시 오류 수정\n","    import matplotlib\n","    matplotlib.rcParams['axes.unicode_minus'] = False"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":31728,"status":"ok","timestamp":1699259893249,"user":{"displayName":"김태식","userId":"11264777984025639378"},"user_tz":-540},"id":"JDVi0qmgxz7T","outputId":"c94d8a3c-6413-4f3f-ba49-32d8f18573de"},"outputs":[{"name":"stderr","output_type":"stream","text":["/usr/local/lib/python3.10/dist-packages/sklearn/datasets/_openml.py:968: FutureWarning: The default value of `parser` will change from `'liac-arff'` to `'auto'` in 1.4. You can set `parser='auto'` to silence this warning. Therefore, an `ImportError` will be raised from 1.4 if the dataset is dense and pandas is not installed. Note that the pandas parser may return different data types. See the Notes Section in fetch_openml's API doc for details.\n","  warn(\n"]}],"source":["# 파일 다운로드\n","from sklearn.datasets import fetch_openml\n","\n","mnist = fetch_openml('mnist_784', as_frame = False) # True시 pandas로 반환"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PNeQPmzdx4Qc"},"outputs":[],"source":["X, y = mnist.data, mnist.target\n","\n","#train_input, test_input, train_target, test_target\n","X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pqmaxFWkrtbc"},"outputs":[],"source":["\"\"\"\n","LogisiticRegressor, RandomforestClassifier 등 다중 레이블을 처리할 수 있는\n","모델도 있지만 SGDClassifier, SVC처럼 이진 분류만 수행 가능한 모델들도\n","여러겹으로 쌓아서 다중 분류를 시행할 수 있음.\n","\"\"\"\n","\n","from sklearn.svm import SVC\n","\n","#SGDClassifier도 똑같이 하면 됨.\n","svm_clf = SVC(random_state = 42)\n","svm_clf.fit(X_train[:2000], y_train[:2000])\n","# 이렇게 하면 10개의 레이블에 대해 총 45번의 비교(OvO 전략)를 시행하고 출력함\n","some_digit_score = svm_clf.decision_function([X[0]])\n","some_digit_score.round(2)\n","\"\"\"\n","array([[ 3.79,  0.73,  6.06,  8.3 , -0.29,  9.3 ,  1.75,  2.77,  7.21,\n","         4.82]]) 여기서 가장 숫자가 높은(9.3) 레이블 5가 제대로 선택됨.\n","물론 보통은 레이블 인덱스와 레이블 이름이 다르기 때문에\n","svm_clf.classes_ 로 9.3에 해당하는 레이블이 뭔지 확인해야함.\n","\"\"\""]},{"cell_type":"code","execution_count":null,"metadata":{"id":"27gsl6EJtmOw"},"outputs":[],"source":["#OvO 전략이 아닌 OvR전략을 강제로 사용하도록 만들수도 있음\n","from sklearn.multiclass import OneVsRestClassifier\n","\n","ovr_clf = OneVsRestClassifier(SVC(random_state = 42))\n","ovr_clf.fit(X_train[:2000], y_train[:2000])\n","some_digit_score = ovr_clf.decision_function([X[0]])\n","some_digit_score.round(2)\n","\"\"\"\n","array([[-1.33, -1.79, -1.39, -0.94, -2.29,  0.81, -1.72, -1.21, -1.64,\n","        -1.79]])\n","\"\"\""]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1062617,"status":"ok","timestamp":1699260973257,"user":{"displayName":"김태식","userId":"11264777984025639378"},"user_tz":-540},"id":"3RfLTGlauwVP","outputId":"5bb010c7-a20e-451d-b0bd-a4c054018828"},"outputs":[{"data":{"text/plain":["array([0.977 , 0.9738, 0.9739])"]},"execution_count":6,"metadata":{},"output_type":"execute_result"}],"source":["from sklearn.model_selection import cross_val_score\n","\n","cross_val_score(svm_clf, X_train, y_train, cv= 3, scoring = 'accuracy',\n","                n_jobs = -1)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"EPAoa11AvJ_C","outputId":"95d29f6c-e330-4b97-bb30-642240171da8"},"outputs":[{"data":{"text/plain":["array([0.9596, 0.9602, 0.961 ])"]},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":["from sklearn.preprocessing import StandardScaler\n","\n","#간단한 표준화처리로 성능을 올릴 수 있다.(svm는 큰 향상 없고 sgd는 5%정도 오름)\n","scaler = StandardScaler()\n","X_train_scaled = scaler.fit_transform(X_train.astype('float64'))\n","cross_val_score(svm_clf, X_train_scaled, y_train, cv = 3, scoring = 'accuracy',\n","                n_jobs = -1)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7CmHXF1Wyo3N"},"outputs":[],"source":["from sklearn.metrics import ConfusionMatrixDisplay\n","from sklearn.model_selection import cross_val_predict\n","import matplotlib.pyplot as plt\n","\n","\"\"\" 오차행렬을 시각화 하는 방법\n","1. 우선 cross_val_predict로 연속적인 예측 데이터를 만듬\"\"\"\n","# 매우 오래 걸림 15\n","y_train_pred = cross_val_predict(svm_clf, X_train_scaled, y_train, cv = 3,\n","                                 n_jobs = -1)"]},{"cell_type":"code","source":["ConfusionMatrixDisplay.from_predictions(y_train, y_train_pred)\n","plt.show()"],"metadata":{"id":"a99rBlcp_s7o"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# 이렇게 하면 정규화되고 백분율로 변환한 오차행렬 표를 볼 수 있음.\n","ConfusionMatrixDisplay.from_predictions(y_train, y_train_pred,\n","                                        normalize ='True',values_format = \".0%\")\n","plt.show()"],"metadata":{"id":"OwYbbubc_86u"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# 이렇게 하면 오류가 어디서 발생했는지 더욱 확실하게 보임\n","wrong_answer = (y_train_pred != y_train) #틀린 애들만 모으기\n","ConfusionMatrixDisplay.from_predictions(y_train, y_train_pred,\n","                                        sample_weight = wrong_answer\n","                                        normalize ='True',values_format = \".0%\")"],"metadata":{"id":"eI0nZ1DgBDOM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["다중 레이블 분류"],"metadata":{"id":"FwtbCDDlDu2q"}},{"cell_type":"code","source":["import numpy as np\n","from sklearn.neighbors import KNeighborsClassifier\n","\n","y_train_large = (y_train >= '7')\n","y_train_odd = (y_train.astype('int8') % 2 == 1)\n","y_multilabel = np.c_[y_train_large, y_train_odd] #다중 레이블 생성\n","\n","knn_clf = KNeighborsClassifier()\n","knn_clf.fit(X_train, y_multilabel) # 간단함."],"metadata":{"id":"tA4caamhDvzh"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# 다중 레이블 분류기를 평가하는 방법\n","from sklearn.metrics import f1_score\n","\n","y_train_knn_pred = cross_val_predict(knn_clf, X_train[:5000], y_multilabel[:5000], cv = 3)\n","f1_score(y_multilabel[:5000], y_train_knn_pred[:5000], average = 'macro')\n","# average를 'weightd'로 지정하면 각 레이블 개수에 따라 가중치를 부여해서\n","# 모든 레이블이 같은 가중치로 훈련받을 수 있게 한다.\n","# 범위 설정 안하면 약97.5% 정도."],"metadata":{"id":"PH5M1ur8EXGI"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\"\"\" 그렇다면 다중레이블을 지원하지 않는 모델에서 다중레이블을 사용하려면 어떻게 할까?\n","ClassifierChain 클래스를 이용하면 된다. 첫 번째 레이블로 모델을 학습하고\n","그 값을 특성에 넣고 두 번째 레이블로 학습하고,,, 의 반복이다.\n","그래서 레이블의 순서를 어떻게 하냐에 따라 결과가 달라질 수 있으며\n","order = 'random'으로 이 문제를 해결한다.\n","설명 : https://bit.ly/3SmzOiL\n","\"\"\"\n","from sklearn.multioutput import ClassifierChain\n","\n","chain_clf = ClassifierChain(SVC(), cv = 3, random_state = 42)\n","chain_clf.fit(X_train[:2000], y_multilabel[:2000])"],"metadata":{"id":"PowLUfFFFBsy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["다중 출력 분류(multioutput classification)\\\n","한 레이블이 다중 클래스가 될 수 있다.(사과는 과일이며, 음식이다)"],"metadata":{"id":"IpMOnYBFO3AS"}},{"cell_type":"code","source":["\"\"\"mnist 숫자에 잡음을 넣고 잡음을 제거하는 시스템\n","분류기의 출력이 다중 레이블(픽셀당 한 레이블)이고\n","각 레이블은 여러 값을 가지니(0 ~ 255) 다중 출력 분류 시스템이라고 함.\"\"\"\n","np.random.seed(42)\n","noise = np.random.randint(0, 100, (len(X_train), 784))\n","X_train_mod = X_train + noise\n","noise = np.random.randint(0, 100, (len(X_test), 784))\n","X_test_mod = X_test + noise\n","#원본 이미지가 타깃임\n","y_train_mod = X_train\n","y_test_mod = X_test\n","\n","def plot_digit(image_data):\n","    image = image_data.reshape(28, 28)\n","    plt.imshow(image, cmap=\"binary\")\n","    plt.axis(\"off\")\n","\n","plt.subplot(121); plot_digit(X_test_mod[0]) # 훈련 세트\n","plt.subplot(122); plot_digit(y_test_mod[0]) # 실제 타겟\n","plt.show()\n","\n","knn_clf = KNeighborsClassifier()\n","knn_clf.fit(X_train_mod, y_train_mod)\n","clean_digit = knn_clf.predict([X_test_mod[0]]) # 예상 타겟\n","plot_digit(clean_digit)\n","plt.show()"],"metadata":{"id":"IATIplBzO36c"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# **연습문제**"],"metadata":{"id":"Yb7OKuy2Si4S"}},{"cell_type":"code","source":["from sklearn.datasets import fetch_openml\n","\n","mnist = fetch_openml('mnist_784', as_frame = False)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"luIv0IWGSphO","executionInfo":{"status":"ok","timestamp":1699268528851,"user_tz":-540,"elapsed":37636,"user":{"displayName":"김태식","userId":"11264777984025639378"}},"outputId":"fd0531ee-7b2a-4290-ec2f-291b2a5ccb02"},"execution_count":25,"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.10/dist-packages/sklearn/datasets/_openml.py:968: FutureWarning: The default value of `parser` will change from `'liac-arff'` to `'auto'` in 1.4. You can set `parser='auto'` to silence this warning. Therefore, an `ImportError` will be raised from 1.4 if the dataset is dense and pandas is not installed. Note that the pandas parser may return different data types. See the Notes Section in fetch_openml's API doc for details.\n","  warn(\n"]}]},{"cell_type":"code","source":["X, y = mnist.data, mnist.target\n","\n","#train_input, test_input, train_target, test_target\n","X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]"],"metadata":{"id":"dkr_5C8oS3DQ","executionInfo":{"status":"ok","timestamp":1699268532074,"user_tz":-540,"elapsed":474,"user":{"displayName":"김태식","userId":"11264777984025639378"}}},"execution_count":26,"outputs":[]},{"cell_type":"code","source":["from scipy.ndimage import shift\n","\n","def shift_image(image, dx, dy):\n","    image = image.reshape((28, 28))\n","    shifted_image = shift(image, [dx, dy], cval = 0, mode = 'constant')\n","    return shifted_image.reshape([-1])\n","\n","image = X_train[1000]\n","shift_left_image = shift_image(image, -5, 0)\n","shift_down_image = shift_image(image, 0, -5)\n","\n","plt.subplot(131)\n","plt.imshow(shift_down_image.reshape(28, 28),\n","           interpolation=\"nearest\", cmap=\"Greys\")\n","plt.subplot(132)\n","plt.imshow(shift_left_image.reshape(28, 28),\n","           interpolation=\"nearest\", cmap=\"Greys\")\n","plt.show()"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":208},"id":"0PA00JLcS6FX","executionInfo":{"status":"ok","timestamp":1699269472185,"user_tz":-540,"elapsed":444,"user":{"displayName":"김태식","userId":"11264777984025639378"}},"outputId":"41bbcf30-3486-450e-9f5e-193d1dc35369"},"execution_count":61,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}]},{"cell_type":"code","source":["X_train_augment = [image for image in X_train]\n","y_train_augment = [label for label in y_train]\n","\n","for dx, dy in ((-1, 0), (0, -1), (1, 0), (0, 1)):\n","    for image, label in zip(X_train, y_train): #image,label을 한번에 불러오려고.\n","        X_train_augment.append(shift_image(image, dx, dy)) # shift한 이미지\n","        y_train_augment.append(label) # target은 그대로여야함.\n","\n","X_train_augment = np.array(X_train_augment)\n","y_train_augment = np.array(y_train_augment)"],"metadata":{"id":"RfdSw4a1W8hV","executionInfo":{"status":"ok","timestamp":1699269828144,"user_tz":-540,"elapsed":50747,"user":{"displayName":"김태식","userId":"11264777984025639378"}}},"execution_count":62,"outputs":[]},{"cell_type":"code","source":["# 순서 섞기\n","shuffle_idx = np.random.permutation(len(X_train_augment))\n","X_train_augment = X_train_augment[shuffle_idx]\n","y_train_augment = y_train_augment[shuffle_idx]"],"metadata":{"id":"pC5qKw4XXzLD","executionInfo":{"status":"ok","timestamp":1699270074403,"user_tz":-540,"elapsed":1889,"user":{"displayName":"김태식","userId":"11264777984025639378"}}},"execution_count":64,"outputs":[]},{"cell_type":"code","source":[" #훈련하기\n","knn_clf = KNeighborsClassifier(n_neighbors = 4, weights = 'distance')\n","knn_clf.fit(X_train_augment, y_train_augment)"],"metadata":{"id":"eDQww0hrY68W"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#점수 매기기\n","augmented_accuracy = knn_clf.score(X_test, y_test)\n","augmented_accuracy"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"vNsUM-PSZETM","executionInfo":{"status":"ok","timestamp":1699270327576,"user_tz":-540,"elapsed":209947,"user":{"displayName":"김태식","userId":"11264777984025639378"}},"outputId":"57e73f27-1056-40e3-fd2c-14520be9e565"},"execution_count":66,"outputs":[{"output_type":"execute_result","data":{"text/plain":["0.9763"]},"metadata":{},"execution_count":66}]},{"cell_type":"code","source":["\"\"\" 정확도는 큰 차이가 없으나 오류율은 크게 줄음\n","grid_search.best_estimator_.fit(X_train, y_train)\n","tuned_accuracy = grid_search.score(X_test, y_test)\n","\n","error_rate_change = (1 - augmented_accuracy) / (1 - tuned_accuracy) - 1\n","print(f\"error_rate_change = {error_rate_change:.0%}\")\n","\"\"\""],"metadata":{"id":"GC0dURe7ZLsN"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":[],"metadata":{"id":"EFEd9ibxZWbX"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"collapsed_sections":["xmbVJ9vurVP7","sYBgxwpFrITN"],"authorship_tag":"ABX9TyPe5S3ziPOJQifXfuHm5RDG"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}